;; This Source Code Form is subject to the terms of the Mozilla Public
;; License, v. 2.0. If a copy of the MPL was not distributed with this
;; file, You can obtain one at https://mozilla.org/MPL/2.0/.


(ns helins.binf.test

  "Testing core view utilities.
  
   R/W tests ensures a few things at once such as:

   - Endianess is randomized
   - Positioning behaves well both in absolute and relative R/W
   - Operating consistenly on subviews"

  {:author "Adam Helins"}

  #?(:clj (:import java.nio.CharBuffer))
  (:require [clojure.string]
            [clojure.test.check.generators   :as TC.gen]
            [clojure.test.check.properties   :as TC.prop]
            [helins.binf                     :as binf]
            [helins.binf.buffer              :as binf.buffer]
            [helins.binf.float               :as binf.float]
            [helins.binf.gen                 :as binf.gen]
            #?(:clj [helins.binf.native      :as binf.native])
            [helins.mprop                    :as mprop]))


#?(:clj (set! *warn-on-reflection*
              true))

;;;;;;;;;; Values


(def view-size
     1024)


;;;;;;;;;; Generic generators


(def gen-endianess

  "Either `:big-endian` or `:little-endian`."

  (TC.gen/elements [:big-endian
                    :little-endian]))



(defn gen-write

  "Given a `src` (buffer or view) and a `n-byte` number of byte that will be written, returns a view
   and a random position to write from (ie. tuple `[position view]`).
  
   The view is created from the source, possibly with an offset and a lower limit."

  [src n-byte]

  (TC.gen/let [endianess gen-endianess
               start     (TC.gen/choose 0
                                        (- view-size
                                           n-byte))
               size      (TC.gen/choose n-byte
                                        (- view-size
                                           start))
               pos       (TC.gen/choose 0
                                        (- size
                                           n-byte))]
    [pos
     (-> src
         (binf/view start
                    size)
         (binf/endian-set endianess))]))


;;;;;;;;;; Base buffers and views


(def src
     (binf.buffer/alloc view-size))



(def src-2

  "On the JVM, represents a native view while in JS, represents a shared buffer.
  
   Both have nothing in common but below tests can be reused across platforms."
  
  #?(:clj  (binf.native/view view-size)
     :cljs (binf.buffer/alloc-shared view-size)))


;;;;;;;;;; Generic properties


(defn prop-rwa

  "Creates a generic property for writing and reading an `n-byte` value generated by `gen` after preparing `src`
   with [[gen-write]], at an absolute position."


  ([src gen n-byte ra wa]

   (prop-rwa src
             gen
             n-byte
             ra
             wa
             =))


  ([src gen n-byte ra wa eq]

   (TC.prop/for-all [x         gen
                     [position
                      view]    (gen-write src
                                          n-byte)]
     (binf/seek view
                0)
     (wa view
         position
         x)
     (mprop/mult

       "Position did not change after writing"
       (zero? (binf/position view))

       "Output is input"
       (eq x
           (ra view
               position))

       "Position did not change after reading"
       (zero? (binf/position view))))))



(defn prop-rwr

  "Like [[prop-rwa]] but from a relative position."


  ([src gen n-byte ra wa]

   (prop-rwr src
             gen
             n-byte
             ra
             wa
             =))


  ([src gen n-byte rr wr eq]

   (TC.prop/for-all [x         gen
                     [position
                      view]    (gen-write src
                                          n-byte)]
     (-> view
         (binf/seek position)
         (wr x))
     (let [position-after (binf/position view)]
       (mprop/mult

         "Output is input after position has been updated"
         (eq x
             (-> view
                 (binf/seek (- (binf/position view)
                              n-byte))
                 rr))

         "After reading, position has been updated"
         (= position-after
            (binf/position view)))))))


;;;;;;;;;; Creating views


(defn gen-create

  "Starting from `src` (buffer or view), creates a subview. Recursif, might repeat the process several time.
  
   Used by [[prop-create]]."

  [[src start limit _endianess]]

  (TC.gen/let [endianess gen-endianess
               offset    (TC.gen/choose 0
                                        limit)
               limit-2   (or (TC.gen/return nil)
                             (TC.gen/choose 0
                                            (- limit
                                               offset)))
               recur?    TC.gen/boolean]
    (let [view (-> src
                   binf/view
                   (binf/endian-set endianess))
          ret  [(if limit-2
                  (binf/view view
                             offset
                             limit-2)
                  (binf/view view
                             offset))
                (+ start
                   offset)
                (or limit-2
                    (- limit
                       offset))
                endianess]]
      (if recur?
        (gen-create ret)
        ret))))



(defn prop-create

  "Tests that a view has been properly created using [[gen-create]]."

  [src]

  (TC.prop/for-all [[view
                     start
                     limit
                     endianess] (gen-create [src
                                             0
                                             view-size])
                    u8          binf.gen/u8]
    (mprop/mult

      "Position is 0 is new view"
      (zero? (binf/position view))

      "Check limit of new view"
      (= limit
         (binf/limit view))

      "Check offset in backing buffer (if any)"
      (if-some [offset (binf/buffer-offset view)]
        (= start
           offset)
        true)

      "Endianess has been copied from source"
      (= endianess
         (binf/endian-get view))

      "Writing in new impacts the original"
      (if (>= limit
              1)
        (do
          (binf/wa-b8 view
                      0
                      u8)
          (= u8
             (binf/ra-u8 (binf/view src)
                         start)))
        true))))




(mprop/deftest create

  {:ratio-num 100}

  (prop-create src))



(mprop/deftest create-2

  {:ratio-num 100}

  (prop-create src-2))


;;;;;;;;;; R/W booleans


(mprop/deftest rwa-bool

  {:ratio-num 100}

  (prop-rwa src
            TC.gen/boolean
            1
            binf/ra-bool
            binf/wa-bool))



(mprop/deftest rwr-bool

  {:ratio-num 100}

  (prop-rwr src
            TC.gen/boolean
            1
            binf/rr-bool
            binf/wr-bool))



(mprop/deftest rwa-bool-2

  {:ratio-num 100}

  (prop-rwa src-2
            TC.gen/boolean
            1
            binf/ra-bool
            binf/wa-bool))



(mprop/deftest rwr-bool-2

  {:ratio-num 100}

  (prop-rwr src-2
            TC.gen/boolean
            1
            binf/rr-bool
            binf/wr-bool))


;;;;;;;;; R/W numbers


(mprop/deftest rwa-i8

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/i8
            1
            binf/ra-i8
            binf/wa-b8))


(mprop/deftest rwa-i16

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/i16
            2
            binf/ra-i16
            binf/wa-b16))


(mprop/deftest rwa-i32

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/i32
            4
            binf/ra-i32
            binf/wa-b32))


(mprop/deftest rwa-i64

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/i64
            8
            binf/ra-i64
            binf/wa-b64))


(mprop/deftest rwa-u8

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/u8
            1
            binf/ra-u8
            binf/wa-b8))


(mprop/deftest rwa-u16

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/u16
            2
            binf/ra-u16
            binf/wa-b16))


(mprop/deftest rwa-u32

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/u32
            4
            binf/ra-u32
            binf/wa-b32))


(mprop/deftest rwa-u64

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/u64
            8
            binf/ra-u64
            binf/wa-b64))


(mprop/deftest rwr-i8

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/i8
            1
            binf/rr-i8
            binf/wr-b8))


(mprop/deftest rwr-i16

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/i16
            2
            binf/rr-i16
            binf/wr-b16))


(mprop/deftest rwr-i32

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/i32
            4
            binf/rr-i32
            binf/wr-b32))


(mprop/deftest rwr-i64

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/i64
            8
            binf/rr-i64
            binf/wr-b64))


(mprop/deftest rwa-f32

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/f32
            4
            binf/ra-f32
            binf/wa-f32
            binf.float/=))


(mprop/deftest rwa-f64

  {:ratio-num 100}

  (prop-rwa src
            binf.gen/f64
            8
            binf/ra-f64
            binf/wa-f64
            binf.float/=))


(mprop/deftest rwr-f32

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/f32
            4
            binf/rr-f32
            binf/wr-f32
            binf.float/=))


(mprop/deftest rwr-f64

  {:ratio-num 100}

  (prop-rwr src
            binf.gen/f64
            8
            binf/rr-f64
            binf/wr-f64
            binf.float/=))


(mprop/deftest rwa-i8-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/i8
            1
            binf/ra-i8
            binf/wa-b8))


(mprop/deftest rwa-i16-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/i16
            2
            binf/ra-i16
            binf/wa-b16))


(mprop/deftest rwa-i32-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/i32
            4
            binf/ra-i32
            binf/wa-b32))


(mprop/deftest rwa-i64-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/i64
            8
            binf/ra-i64
            binf/wa-b64))


(mprop/deftest rwa-u8-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/u8
            1
            binf/ra-u8
            binf/wa-b8))


(mprop/deftest rwa-u16-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/u16
            2
            binf/ra-u16
            binf/wa-b16))


(mprop/deftest rwa-u32-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/u32
            4
            binf/ra-u32
            binf/wa-b32))


(mprop/deftest rwa-u64-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/u64
            8
            binf/ra-u64
            binf/wa-b64))


(mprop/deftest rwr-i8-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/i8
            1
            binf/rr-i8
            binf/wr-b8))


(mprop/deftest rwr-i16-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/i16
            2
            binf/rr-i16
            binf/wr-b16))


(mprop/deftest rwr-i32-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/i32
            4
            binf/rr-i32
            binf/wr-b32))


(mprop/deftest rwr-i64-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/i64
            8
            binf/rr-i64
            binf/wr-b64))


(mprop/deftest rwa-f32-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/f32
            4
            binf/ra-f32
            binf/wa-f32
            binf.float/=))


(mprop/deftest rwa-f64-2

  {:ratio-num 100}

  (prop-rwa src-2
            binf.gen/f64
            8
            binf/ra-f64
            binf/wa-f64
            binf.float/=))


(mprop/deftest rwr-f32-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/f32
            4
            binf/rr-f32
            binf/wr-f32
            binf.float/=))


(mprop/deftest rwr-f64-2

  {:ratio-num 100}

  (prop-rwr src-2
            binf.gen/f64
            8
            binf/rr-f64
            binf/wr-f64
            binf.float/=))


;;;;;;;;;; Copying from/to buffers


(defn buffer-erase

  "Erases `n-byte` bytes from `buffer` starting at `offset` by zeroing that portion."

  [buffer offset n-byte]

  (let [view (binf/view buffer
                        offset
                        n-byte)]
    (dotimes [_ n-byte]
      (binf/wr-b8 view
                  0))))



(defn gen-write-buffer

  "Generates arguments for R/W a buffer from a view.
  
   Used by [[prop-rwa-buffer]] and [[prop-rwr-buffer]."

  [src]

  (TC.gen/let [n-byte-buffer (TC.gen/choose 0
                                            view-size)
               [position
                view]        (gen-write src
                                        n-byte-buffer)
               buffer        (binf.gen/buffer n-byte-buffer)
               n-byte-copy   (TC.gen/choose 0
                                            n-byte-buffer)
               offset        (TC.gen/choose 0
                                            (- n-byte-buffer
                                               n-byte-copy))]
    [view
     position
     buffer
     offset
     n-byte-copy]))



(defn prop-rwa-buffer

  "Writes and then reads back a buffer from an absolute position in a view created from `src`."

  [src]

  (TC.prop/for-all [[view
                     position
                     buffer
                     offset
                     n-byte]  (gen-write-buffer src)]
    (-> view
        (binf/seek 0)
        (binf/wa-buffer position
                        buffer
                        offset
                        n-byte))
    (let [target (doall (seq buffer))]
      (buffer-erase buffer
                    offset
                    n-byte)
      (mprop/mult

        "Position did not change after writing"
        (zero? (binf/position view))

        "Reading back what has been written"
        (= target
           (-> view
               (binf/ra-buffer position
                               n-byte
                               buffer
                               offset)
               seq))

        "Position did not change after reading"
        (zero? (binf/position view))))))



(defn prop-rwr-buffer

  "Like [[prop-rwa-buffer]] but from a relative position."

  [src]

  (TC.prop/for-all [[view
                     position
                     buffer
                     offset
                     n-byte]  (gen-write-buffer src)]
    (-> view
        (binf/seek position)
        (binf/wr-buffer buffer
                        offset
                        n-byte))
    (let [position-after (binf/position view)
          target         (doall (seq buffer))]
      (buffer-erase buffer
                    offset
                    n-byte)
      (mprop/mult

        "Reading back what has been written after deducing the right position"
        (= target
           (-> view
               (binf/seek (- (binf/position view)
                             n-byte))
               (binf/rr-buffer n-byte
                               buffer
                               offset)
               seq))

        "Position has been updated after reading"
        (= position-after
           (binf/position view))))))



(mprop/deftest rwa-buffer

  {:ratio-num 50}

  (prop-rwa-buffer src))



(mprop/deftest rwr-buffer

  {:ratio-num 50}

  (prop-rwr-buffer src))



(mprop/deftest rwa-buffer-2

  {:ratio-num 50}

  (prop-rwa-buffer src-2))



(mprop/deftest rwr-buffer-2

  {:ratio-num 50}

  (prop-rwr-buffer src-2))


;;;;;;;;;; R/W strings that fit in a single view


(defn gen-string

  "Generates a random string that can fit within `src`, as well as a view on `src` and a position to R/W the string."

  [src]

  (TC.gen/let [n-char (TC.gen/choose 0
                                     (Math/floor (/ view-size
                                                    4))) ;; Can accomodate any UTF-8 string within the view
               [pos
                view] (gen-write src
                                 (* 4
                                    n-char))
               string (TC.gen/fmap clojure.string/join
                                   (TC.gen/vector TC.gen/char
                                                  0
                                                  n-char))]
    [view
     pos
     string]))



(defn prop-rwa-string

  "Writes and reads back a generated string from a generated absolute position in a view created from `src`."

  [src]

  (TC.prop/for-all [[view
                     position
                     string]  (gen-string src)]
    (binf/seek view
               0)
    (let [[finished?
           n-byte
           n-char
           #?(:clj char-buffer)] (binf/wa-string view
                                                 position
                                                 string)]
      (mprop/mult

        "Position did not change after writing"
        (zero? (binf/position view))

        "Writing oeration is finished"
        finished?

        "All characters have been written"
        (= (count string)
           n-char)

        #?@(:clj ["There is no char-buffer for continuing the operation"
                  (nil? char-buffer)])

        "Reading back the written strings"
        (= string
           (binf/ra-string view
                           position
                           n-byte))

        "Position did not change after reading"
        (zero? (binf/position view))))))



(defn prop-rwr-string

  "Like [[prop-rwa-string]] but from a relative position."

  [src]

  (TC.prop/for-all [[view
                     position
                     string]  (gen-string src)]
    (let [[finished?
           n-byte
           n-char
           #?(:clj char-buffer)] (-> view
                                     (binf/seek position)
                                     (binf/wr-string string))
          position-after         (binf/position view)]
      (mprop/mult

        "Writing operation is finished"
        finished?

        "All characters have been written"
        (= (count string)
           n-char)

        #?@(:clj ["There is no char-buffer for continuing the operation"
                  (nil? char-buffer)])

        "Reading back the written string after deducing the position"
        (= string
           (-> view
               (binf/seek (- position-after
                             n-byte))
               (binf/rr-string n-byte)))

        "Position did not change after reading"
        (= position-after
           (binf/position view))))))



(mprop/deftest rwa-string

  {:ratio-num 50}

  (prop-rwa-string src))



(mprop/deftest rwr-string

  {:ratio-num 50}

  (prop-rwr-string src))



(mprop/deftest rwa-string-2

  {:ratio-num 50}

  (prop-rwa-string src-2))



(mprop/deftest rwr-string-2

  {:ratio-num 50}

  (prop-rwr-string src-2))


;;;;;;;;;; R/W strings that does NOT fit into a single view


(defn gen-string-big

  "Like [[gen-string]] but generates a string that is to big to fit in the view create from `src`."

  [src]

  (TC.gen/let [n-byte    (TC.gen/choose 0
                                        view-size)
               [position
                view]    (gen-write src
                                    n-byte)
               string    (TC.gen/fmap clojure.string/join
                                      (let [n-char-min (inc (- (binf/limit view)
                                                               position))]
                                        (TC.gen/vector TC.gen/char
                                                       n-char-min
                                                       (+ n-char-min
                                                          (Math/ceil (/ view-size
                                                                        2))))))]
    [view
     position
     string]))



(defn prop-rwa-string-big

  "Like [[prop-rwa-string]] but tests that only part of the string generated by [[gen-string-big]]
   has effectively been processed."

  [src]

  (TC.prop/for-all [[view
                     position
                     string]  (gen-string-big src)]
    (binf/seek view
               0)
    (let [[finished?
           n-byte
           #?(:clj  _n-char
              :cljs n-char)
           #?(:clj char-buffer)] (binf/wa-string view
                                                 position
                                                 string)]
      (mprop/mult

        "Position did not change after writing"
        (zero? (binf/position view))

        "Writing is not finished"
        (not finished?)

        "String can be recomputed by reading what has been written and concatenating with what is remaining"
        (= string
           (str (binf/ra-string view
                                position
                                n-byte)
                #?(:clj  (.toString ^CharBuffer char-buffer)
                   :cljs (.substring string
                                     n-char))))

        "Position did not change after reading"
        (zero? (binf/position view))))))




(defn prop-rwr-string-big

  "Like [[prop-rwa-string-big]] but from a relative position."

  [src]

  (TC.prop/for-all [[view
                     position
                     string]  (gen-string-big src)]
    (let [[finished?
           n-byte
           #?(:clj  _n-char
              :cljs n-char)
           #?(:clj char-buffer)] (-> view
                                     (binf/seek position)
                                     (binf/wr-string string))
          position-after         (binf/position view)]
      (mprop/mult

        "Operation is not finished"
        (not finished?)

        "String can be recomputed by reading what has been written and concatenating with what is remaining"
        (= string
           (str (-> view
                    (binf/seek (- position-after
                                  n-byte))
                    (binf/rr-string n-byte))
                #?(:clj  (.toString ^CharBuffer char-buffer)
                   :cljs (.substring string
                                     n-char))))

        "Position has been updated after reading"
        (= position-after
           (binf/position view))))))



(mprop/deftest rwa-string-big

  {:ratio-num 50}

  (prop-rwa-string-big src))



(mprop/deftest rwr-string-big

  {:ratio-num 50}

  (prop-rwr-string-big src))



(mprop/deftest rwa-string-big-2

  {:ratio-num 50}

  (prop-rwa-string-big src-2))



(mprop/deftest rwr-string-big-2

  {:ratio-num 50}

  (prop-rwr-string-big src-2))


;;;;;;;;;; Reallocating views


(defn prop-grow

  "Tests that growing a view copies what needs to be copied and that the new view converses needed
   properties of the original (endianess and position)."

  [src]

  (let [view     (binf/view src)
        view-vec (vec (binf/ra-buffer view
                                      0
                                      view-size))]
    (TC.prop/for-all [endianess         gen-endianess
                      n-additional-byte (TC.gen/choose 0
                                                       view-size)
                      position          (TC.gen/choose 0
                                                       (- view-size
                                                          8))
                      u64               binf.gen/u64]
      (let [view-2  (binf/grow (-> view
                                   (binf/endian-set endianess)
                                   (binf/seek position))
                               n-additional-byte)
            limit-2 (binf/limit view-2)]
        (mprop/mult

          "New size is adequate"
          (= (+ view-size
                n-additional-byte)
             (binf/limit view-2))

          "Original buffer has been copied"
          (= (seq (binf/ra-buffer view-2
                                  0
                                  limit-2))
             (concat view-vec
                     (repeat n-additional-byte
                             0)))

          "Position is preserved"
          (= position
             (binf/position view)
             (binf/position view-2))

          "Endianess is preserved"
          (= endianess
             (binf/endian-get view-2))

          "Type is preserved"
          (= (type view)
             (type view-2))

          "Writing in new does not impact the original"
          (let [before (binf/ra-u64 view
                                    position)]
            (binf/wa-b64 view-2
                         position
                         u64)
            (= before
               (binf/ra-u64 view
                            position))))))))



(mprop/deftest grow

  {:ratio-num 50}

  (prop-grow src))



(mprop/deftest grow-2

  {:ratio-num 50}

  (prop-grow src-2))
